\documentclass[11pt,a4paper,notitlepage]{article}

    \usepackage[margin=1in]{geometry}
    \usepackage{algorithm}
    \usepackage{algpseudocode}
    \usepackage{graphicx}
    \usepackage{subcaption}
    \usepackage{mwe}
    \usepackage{amsmath}
    \usepackage{float}
    \usepackage{multicol}

    \title{CCS - Network Analysis Assignment}
    \author{Fatema Alkhanaizi}
    \date{\today}

\begin{document}

\graphicspath{ {../distributions/q2/} {../distributions/q1/} {../distributions/q3/} }

\maketitle

\noindent
Clearly document what you have done. For each question you should report on what you did and include, as needed, illustrative plots.

\section*{Question 1}
\subsection*{Ring Group Graph implementation}
The ring group graph was implemented based on the following steps:
\begin{enumerate}
    \item For each vertex from 0 to m * k (outer loop) where m is the number of groups and k is the number of members per group, the group label was calculated by dividing the current vertex id [0,m * k) over k, then truncate the value so only the integer value remains from the division
    \item The vertex was then iterated over the other vertices (inner loop) starting from the current vertex id plus 1 until m * k. 
    \item At each iteration of the inner loop, the group was computed again for the inner loop's vertex and checked against the outer loop's group:
    \begin{itemize}
        \item if the groups are the same or adjacent (absolute difference is one or absolute difference is m - 1, the group difference for the first and last group), then there is a p probability that an edge exists
        \item all other cases, there is a q probability that an edge exists
    \end{itemize}
\end{enumerate}
\textbf{networkx} python3 package was used to create the graph and to check that the graph instances used for the degree distribution are fully connected (all unconnected graphs were skipped). It was also used to calculate the diameter of the graph (next section).

\subsection*{Ring Group Graph Degree Distribution when $p + q = 0.5$, $p > q$}
\begin{itemize}
    \item Investigate the degree distribution of Ring Group Graphs for p + q = 0.5, p > q. 
    \item Decide which values of m, k, p and q to investigate. 
    \item You should report on how the structure changes as p and q vary and whether the same effects are found for different values of m and k.
    \item Use plots to illustrate your observations.
\end{itemize}
\noindent
The degree distrbution was normalized and averaged over 25 instances of the ring group graph. The following figures are for the case when $p + q = 0.5$, $p > q$:
\begin{figure}[H] 
    \centering
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{50-20-0.01}.png}
        \subcaption{m = 50, k = 20}
        \label{pq0.5:m50k20}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{20-50-0.01}.png}
        \subcaption{m = 20, k = 50}
        \label{pq0.5:m20k50}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{6-100-0.01}.png}
        \subcaption{m = 6, k = 100}
        \label{pq0.5:m6k100}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{4-100-0.1}.png}
        \subcaption{m = 4, k = 100}
        \label{pq0.5:m4k100}
    \end{minipage}
    \caption{Ring Group Graph when $p + q = 0.5$, $p > q$}
    \label{rgg:pq0.5}
\end{figure}
\noindent
By the Ring Group graph definition each vertex can be linked to 3 groups (two adjacent groups and its own group) and since each group has k members there is $p \times (3k-1)$ edges the verrex can be conneced to on average with this condition (the subtracted 1 is the vertex itself - no self edges allowed). So, the average for the remaining edges is $q \times k \times (m-3)$ (the vertices connected with p substracted from all the vertices). So, the degree distribution figures can be explained by these equations:
\begin{align*} \label{rgg:vad}
    \mu_{degree} &= p \times (3k - 1) + q \times k \times (m-3) \\
    \sigma_{degree} &= \sqrt{(1-p) \times p \times (3k - 1)} + \sqrt{(1-q) \times q \times k \times (m-3))}
\end{align*} 
 The general shaped of the degree distribution for a Ring Group Graph is a bell shaped. A vertex average degree is heavly infllued by the value of k which is evident in figure-\ref{pq0.5:m20k50} and figure-\ref{pq0.5:m50k20}; for the same number of nodes, p and q values, the distribution in figure-\ref{pq0.5:m20k50} is shifted toward greater degree distribution than in figure-\ref{pq0.5:m50k20}. 
% ToDo talk about figures 1c and 1d.


\subsection*{Diameter of Ring Group Graph and $p$ (for a fixed $q$, $p > q$)}
\begin{itemize}
    \item Investigate the relationship between the diameter of Ring Group Graphs and p (for fixed q, p > q). 
\end{itemize}
The diameter was caluculated over 20 instances of the ring group graph and run against multiple fixed q values and tested against two m and k values (20 and 50):
\begin{figure}[H]
    \centering
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{diameter/50-20}.png}
        \subcaption{m = 50, k = 20}
        \label{dia:m50k20}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{diameter/20-50}.png}
        \subcaption{m = 20, k = 50}
        \label{dia:m20k50}
    \end{minipage}
    \caption{Diameter for Ring Group Graph when $p > q$ ($q$ is fixed)}
    \label{rgg:dia}
\end{figure}
\noindent
The picked values for m and k provided a good contrast on how the diameter is affected when m is greater than k and vice versa. As shown in figure-\ref{rgg:dia}, as p increases the diameter decreases and at some point it becomes constant. For various q values the diamter had a similar behaviour, the value of the diameter was generally higher as q decreased which is expected as the probability q essentially creates shortcuts between the groups and without those shortcuts the diameter depends on the value of m and p. 

\begin{figure}[H]
    \centering
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{prob-p/50-20-0.01}.png}
        \subcaption{m = 50, k = 20, q = 0.01}
        \label{dd:m50k20}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{prob-p/20-50-0.01}.png}
        \subcaption{m = 20, k = 50, q = 0.01}
        \label{dd:m20k50}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{prob-p/6-100-0.01}.png}
        \subcaption{m = 6, k = 100, q = 0.01}
        \label{dd:m6k100}
    \end{minipage}
    \caption{Ring Group Graph when $p > q$ ($q$ is fixed)}
    \label{rgg:dd}
\end{figure}
\section*{Question 2}
\subsection*{Distribution of Vertex Brilliance}
\subsubsection*{Calculating Vertex Brilliance}
\begin{itemize}
    \item Construct the undirected graph defined in coauthorship.txt. Ignore edge weights.
    \item For the graph from coauthorship.txt, investigate the distribution of vertex brilliance. 
    \item For each of the following types of graph
    \begin{itemize}
    \item PA Graphs
    \item Ring Group Graphs 
    \end{itemize}
    create examples with approximately the same number of vertices and edges as the graph from coauthorship.txt and investigate the distribution of vertex brilliance. Comment on what you find.
\end{itemize}
The vertex brilliance was caluculated based on a similar approach to calculate the diameter by using breadth-first search but by only doing breadth-first search at debth of 2; by checking the neighbours of the vertex's neighbours. The algorithm simplified:
\begin{enumerate}
    \item create an empty dictionary; this dictionary will hold the weight vertices for the k-star of the current vertex 
    \item populate the dictionary with v's neighbours and give each vertex in the dictionary a weight of 0 to begin with < this weight will be used to determine which vertex to exclude to get the maximum k-star, the weight corresponds to how many v's neighbours the vertex is connected to
    \item repeat until maximum k-star is found
    \begin{itemize}
        \item for each vertex in the k-star dictionary go through its neighbours. If one of the vertex neighbour is a key in the k-star dictionary substract 1 from the weight of the vertex (I gave it negative value as just a notion that this is undesired vertex thus a negative affect but it can be calculated with the same manner by adding 1 but then the rest of the code will be modified so it get the maximum value from the k-star values instead of the minimum)
        \item find the minimum weight (value) of the k-star dictionary 
        \item if the minimum value is 0 then stop as this indicates that non of the vertices in the dictionary are adjacent thus it is the maximum k-star set of vertices (ther can be more than one set but we only care about the length so the actual vertices of the maximum set don't have any actual value for us in this case) so stop the loop
        \item else find the vertex with the minumum weight and remove it from the dictionary (this vertex is the most influential as it connects to the most number of vertices and by removing it the rest of vertices will be less adjacent, only the first found vertix will be removed) and reset all the other vertices values to 0 
    \end{itemize}
    \item return the length of the dictionary 
\end{enumerate}
This is essentially an algorithm to get the maximum independent set of sub-graph that only contains v and it's neighbours. I opted to using my own algorithm instead of using networkx's implementation. 
\subsubsection*{Creating Vertex Brilliance Distribution}
For each generated graphs (PA graph and Ring Group graph), the vertex brilliance distribution was averaged and normalized over 100 instances. The distribution was created following the same code as the degree distribution.

\subsection*{Vertex Brilliance Results}
\subsubsection*{Co-authorship Graph}
The co-authorship graph was loaded by following code provided in the lectures; it was just basic file-reading and making sure that the edges were undirected. The following figures are the degree distribution (in blue) and the vertex brilliance distribution (in red) of the graph:
\begin{figure}[H]
    \centering
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{coauthorship-vertex-degree.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{coauthorship-vertex-brilliance.png}
    \end{minipage} \hfill
    \caption{Loaded Co-authorship Graph including vertices with no edges}
\end{figure}
The general shape of both graphs is skewed to the right.

\subsubsection*{PA Graph}
As the implementation of the PA Graph that we used in the lectures was directed, I modified networkx implementation and matched it to the PA Graph specifications provided in lecture:
\begin{itemize}
    \item I made the first 1 to m vertices fully connected and repeated each vertex m times in a list for selecting the new edges for the remaining vertices
    \item For the remaining m + 1 to n vertices, I randomly picked a vertex from the previous list m times (created an edge). For each iteration until n is reached, I added the new vertex m times in the selection list along with its neighbours.
\end{itemize} 
\begin{figure}[H]
    \centering
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{pa_graph-1559-30-degree.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{pa_graph-1559-30-brilliance.png}
    \end{minipage} \hfill
    \caption{PA Graph parameters: m = 1559, m = 30}
\end{figure}
Both distributions has been averaged over 100 instances of the PA graph. The resulted graphs for both degree and vertex brilliance distributions are skewed to the right. The co-authorship graph strongly resembles the PA graph based on the distributions. 

\subsubsection*{Ring Group Graph}
To get approximately the same number of edges and nodes as the co-authorship graph, the following parameters were used: m = 60, k = 26, p = 0.22, q = 0.03; there are other possible parameters but their distributions are similar to the distributions with the paramaters used here (in terms of shape). 
\begin{figure}[H]
    \centering
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{ring_group_graph-60-26-0.22-0.03-degree}.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{ring_group_graph-60-26-0.22-0.03-brilliance}.png}
    \end{minipage} \hfill
    \caption{Ring Group Graph parameters: m = 60, k = 26, p = 0.22, q = 0.03}
\end{figure}
\begin{figure}[H]
    \centering
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{ring_group_graph-120-13-0.26-0.04-degree}.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{ring_group_graph-120-13-0.26-0.04-brilliance}.png}
    \end{minipage} \hfill
    \caption{Ring Group Graph parameters: m = 120, k = 13, p = 0.26, q = 0.04}
\end{figure}
Both distributions are bell shaped (binomial distribution).
\\ \\
Based on the previous graphs, it can be concluded that the vertex distribution has the same shape as the degree distribution and the co-authorship graph closely resembles the PA graph. 




\section*{Question 3}
The search time for a given start and target is the total number of queries made in reaching the target from the start (the number of intermediate vertices is not counted). The search time for a graph is the average search time over all pairs of start and target vertices. Clearly these times depend on the algorithm used for deciding when to query, when to move to a new vertex and how to decide which vertex to move to. The aim is that the search time is as small as possible.
\\
\noindent
Note that the array of neighbours of a vertex should not be considered ordered. If you create graphs in such a way that the neighbours are ordered, then either randomize the ordering or, when querying the array of neighbours, choose a random member of the array (from amongst those not already queried).

\begin{itemize}
    \item describe an algorithm for searching in the graphs. (I expect that you will have different algorithms for the different types of graphs.) 
    \item You should explain why you believe your strategy might be effective and implement and test it on many instances. You can choose the parameters yourself as long as you are not perverse — for example, the groups in the Ring Group Graph should not be of size 1 or n — and it is acceptable that all your testing for a particular type of graph is on instances generated with the same parameters. 
    \item As searching on graphs that are not connected can be impossible, you should choose parameters so that the graphs are very likely to be connected. 
    \item Plot search time against the number of instances that achieve that time. Comment on your plots. It is acceptable to estimate search time by looking at only a sample set of pairs of vertices. 
    \item Credit will be given for the effectiveness of the algorithm you design, and also, independently, for your explanation of the rationale behind the design.
\end{itemize}

\subsection*{Search Random Graph}
\subsubsection*{Search Algorithm}
The search in a Random Graph was implemented as follow:
\begin{itemize}
    \item Inputs:
    \begin{itemize}
        \item The graph
        \item The graph parameters - (n, p)
        \item The start vertex id - (numerical id)
        \item The target vertex id - (numerical id)
    \end{itemize}
    \item Initialize a variable for search time and set it to 0
    \item Calculate the average number of neighbours based on the number of nodes and p
    \item start an infinite loop until the target vertex is found:
    \begin{itemize}
        \item shuffle the current vertex's neighbours list (at the beginning it is the start vertex)
        \item check if then number of neighbours is more than average if so then set the number of iterations up until the average
        \item Iterate over the neighbours' list:
        \begin{itemize}
            \item increment the search time by 1 for every iteration that happens
            \item if the neighbour's id matches the target's id then stop, break out of the loop and return the search time
            \item else move to the neighbour with a probability p (the probability of the random graph)
        \end{itemize}
        \item if no moves were made move to the last queried neighbour
    \end{itemize}
\end{itemize}
The algorithm above made use of the general knowledge of the graph i.e. total number of nodes (n) and the probability (p) that an edge exists between each pair of nodes in addition to the local knowledge i.e. vertex id and number of its neighbours to better find the target vertex (t). Every vertex has the same probability to be connected to t, so there is no need to iterate over all the neighbours and going until the average number (extrapolated from the general knowledge) should suffice. This is evident from the search time distribution in figure- and figure-; going only until the average number of neighbours slightly improves the search espcially for bigger values of n.  

\subsubsection*{Search Time Distribution}
The search time distribution was created by searching 30,000 random pairs of vertices normalized and averaged over 10 random graph instances. The plots below were created to look into the search time distribution for a random graph and how it was affected by the total number of nodes (n) and probability p:

\noindent
Figure- and figure- had a constant probability p and an increasing n. As n increased the search time increased as well which is an expected behaviour as more edges and vertices will be iterated over. \\

\noindent
On the other hand, figure- and figure- had a constant n and an increasing p. As p increased the search time increased as well which is an expected behaviour as more edges and vertices will be iterated over. 

\subsection*{Search Ring Group Graph}
\subsubsection*{Search Algorithm}
By definition all vertices in Ring Group graph are part of a group and adjacent groups have higher probability (p) of having an edge between their vertices than other groups which have a lower probability (q). So, the most basic strategy for searching is to move to the closest group or if possible to a group adjacent to the target vertex and look for the target in that group because of the higher probability. Unlike Random graph not all vertices are connected with the same probability and the group number is part of the vertex id so it helps narrow the search significantly. Based on that the search in a Ring Group graph was implemented as follows:
\begin{itemize}
    \item Inputs:
    \begin{itemize}
        \item The graph
        \item The graph parameters - (m, k, p, q)
        \item The start vertex id - (numerical id, group)
        \item The target vertex id - (numerical id, group)
    \end{itemize}
    \item Initialize a variable for search time and set it to 0
    \item Create a variable for the probability to move to a vertex that is closer to the target's group than the current vertex and set it to be equal to p; call it prob\_close. This value was determined through trial and error and proved to provide the best results. The higher the p value, the less relevent the q value for the algorithm becomes as evident from Figure-\ref{rggs:mgpv2} and Figure-\ref{rggs:kgpv2} where the search time average of 20 graph instances over 50 pair of vertices each ran 10 times plotted against a fixed q and an increasing p (same conditions as the diameter plot)
    \item check if p is greater than 0.5, if it is then set p to 1 - p; this check is to make it less likely to move to another vertex in the group to find the target vertex as the high probability indicates that it is very likely that the target vertex is connected to the current vertex
    \item start an infinite loop until the target vertex is found:
    \begin{itemize}
        \item shuffle the current vertex's neighbours list (at the beginning it is the start vertex)
        \item Iterate over the neighbours list:
        \begin{itemize}
            \item increment the search time by 1 for every iteration that happens
            \item if the neighbour's id matches the target's id then stop, break out of the loop and return the search time
            \item else if the neighbour's group is the same as the traget's group then move to that neighbour with a probability p (the probability for vertices in adjacent groups to have an edge), otherwise keep track of this neighbour in adjacent\_neighbour variable (only one neighbour is stored at a time so if another neighbour with the same condition is encountered that neighbour will be stored instead and as the neighbours list is shuffled with every move it is less likely this neighbour will be the same if the current vertex is returned to at some point)
            \item else if the neighbour's group is closer to the target than the current vertex move to that neighbour with the probability that we set at the beginning of this algorithm (prob\_close) otherwise keep track of this neighbour - closest\_not\_adjacent\_v - the same way as the previous condition
            \item else move to this neighbour with a probability of q (probability of an edge )
        \end{itemize}
        \item if no moves has been made check if adjacent\_neighbour has been assigned and move to it, otherwise check if closest\_not\_adjacent\_v has been assigned and move to it, else move to the last queried neighbour
    \end{itemize}
\end{itemize}


\subsubsection*{Search Time Distribution}
To insure that the graph instance was connected, networkx package was used for both creating the graph using networkx graph structure and then checking if it's connected (all nodes have an edge between them). The following plots are the search time against the number of instances that achieve that time evaluated for 50,000 randomly picked pairs of vertices each searched for 5 times and averaged and ran over 10 instances of the ring group graph and averaged again:
\noindent
The paramaters picked for the ring group graph instances tested here were based on the results in Figure-\ref{rggs:mgp} and Figure-\ref{rggs:kgp}. The figures demonstrate the effictiveness of the algorithm by looking into relationship between the search time and the probability p (groups are more connected) tested over low q probabilities (less chance of shortcuts appearing the graph). The algorithm performs better with greater m values and greater p values.

\section*{Appendix}
\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{ring_group_graph-50-20-search_time-p-mGreater}.png}
        \subcaption{without the probability to move to a closer neighbour nor reset p value when p is more than 0.5}
        \label{rggs:mgpv1}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{ring_group_graph-50-20-search_time_v2-p-mGreater}.png}
        \subcaption{with the probability to move to a closer neighbour set to p and reset p value when p is more than 0.5}
        \label{rggs:mgpv2}
    \end{minipage} \hfill
    \caption{Ring Group Graph parameters: m = 50, k = 20}
    \label{rggs:mgp}
\end{figure}
\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{ring_group_graph-20-50-search_time-p-kGreater}.png}
        \subcaption{without the probability to move to a closer neighbour nor reset p value when p is more than 0.5}
        \label{rggs:kgpv1}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{{ring_group_graph-20-50-search_time_v2-p-kGreater}.png}
        \subcaption{with the probability to move to a closer neighbour set to p and reset p value when p is more than 0.5}
        \label{rggs:kgpv2}
    \end{minipage} \hfill
    \caption{Ring Group Graph parameters: m = 20, k = 50}
    \label{rggs:kgp}
\end{figure}

\end{document}